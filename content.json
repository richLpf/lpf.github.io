[{"title":"golang使用gin框架搭建工作项目","date":"2020-05-05T15:59:41.000Z","path":"2020/05/05/golang使用gin框架搭建工作项目/","text":"从零搭建一个go项目涉及到的技术 gin mysql gorm swagger docker shell 实现功能1、通过环境变量配置不同的打包环境 2、打包镜像实现自动化打包，版本的记录和回退 3、通过组织代码，将代码的分层 4、引入mod包管理工具 5、通过swagger自动生成文档 一、新建一个go文件新建文件夹mkdir myapp 使用mod版本管理go mod init myapp 自动生成go.mod文件 注意 golang 安装后默认环境变量 GO111MODULE=auto, 如果需要使用mod管理包，需要设置GO111MODULE=on go get github.com/gin-gonic/gin 下载gin包，mod会自动记录 12345678910111213141516171819202122232425package mainimport ( &quot;net/http&quot; &quot;github.com/gin-gonic/gin&quot;)func main() &#123; router := gin.Default() router.GET(&quot;/list&quot;, GetUserList) router.GET(&quot;/detail/:id&quot;, GetDetail) router.Run(&quot;:9001&quot;)&#125;//GetUserList get userfunc GetUserList(c *gin.Context) &#123; c.JSON(http.StatusOK, gin.H&#123;&quot;RetCode&quot;: 0, &quot;Msg&quot;: &quot;success&quot;&#125;)&#125;//GetDetail update userfunc GetDetail(c *gin.Context) &#123; id := c.Param(&quot;id&quot;) c.JSON(http.StatusOK, gin.H&#123;&quot;RetCode&quot;: 0, &quot;Msg&quot;: &quot;success&quot;, &quot;Id&quot;: id&#125;)&#125; 一个main包，此时我们还没有引入数据库和其他的一些配置，但实际工作中，我们不可能用一个包来写所有的代码,所以接下来我们用controller目录来将请求的接口整理 二、将请求的函数放在controller中新建controller/user/user.go cat user.go 123456789101112131415161718package userimport ( &quot;net/http&quot; &quot;github.com/gin-gonic/gin&quot;)//GetUserList get userfunc GetUserList(c *gin.Context) &#123; c.JSON(http.StatusOK, gin.H&#123;&quot;RetCode&quot;: 0, &quot;Msg&quot;: &quot;success&quot;&#125;)&#125;//GetDetail update userfunc GetDetail(c *gin.Context) &#123; id := c.Param(&quot;id&quot;) c.JSON(http.StatusOK, gin.H&#123;&quot;RetCode&quot;: 0, &quot;Msg&quot;: &quot;success&quot;, &quot;Id&quot;: id&#125;)&#125; 此时cat main.go 1234567891011121314package mainimport ( &quot;myapp/controller/user&quot; &quot;github.com/gin-gonic/gin&quot;)func main() &#123; router := gin.Default() router.GET(&quot;/list&quot;, user.GetUserList) router.GET(&quot;/detail/:id&quot;, user.GetDetail) router.Run(&quot;:9001&quot;)&#125; 通过引入user包，将user中的方法引入 当前目录结构 123456├─controller 控制器│ |--user 用户相关接口| |--user.go|—go.mod mod管理器|—go.sum 自动生成记录包的版本|—main.go main包，入口文件 之后新增的业务接口，统一放在controller中 二、将路由分离出来单独维护新建 router/router.go cat router.go 12345678910111213141516171819202122232425262728package routerimport ( &quot;myapp/controller/passage&quot; &quot;myapp/controller/user&quot; &quot;github.com/gin-gonic/gin&quot;)//Router 路由func Router() *gin.Engine &#123; router := gin.New() // 使用中间件 // 使用Logger中间件 router.Use(gin.Logger()) // 使用Recovery中间件 router.Use(gin.Recovery()) userRouter := router.Group(&quot;/user&quot;) userRouter.GET(&quot;list&quot;, user.GetUserList) userRouter.GET(&quot;detail/:id&quot;, user.GetDetail) passageRouter := router.Group(&quot;/passage&quot;) passageRouter.GET(&quot;list&quot;, passage.GetPassageList) passageRouter.POST(&quot;add&quot;, passage.AddPassage) return router&#125; 这里除了将路由独立出来，还增加了中间件和路由分组 此时cat main.go 12345678package mainimport &quot;myapp/router&quot;func main() &#123; apiRouter := router.Router() apiRouter.Run(&quot;:9000&quot;)&#125; 我们看到main.go文件的内容是不是少多了，仅仅引入router包，启动路由 router.Group 会将路由分成组，访问路由为 /user/list user/detail/:id 注意 gin.New() 和gin.Default() 的区别 123gin.New() 仅仅创建一个路由，并不会包含Logger()和gin.Recovery()中间件，gin.Default() 创建的路由会默认添加 Logger() 和Recovery() 中间件所以如果你需要自己引入日志中间件或者恢复的中间件，可以使用gin.New() 此时目录结构为 12345678910├─controller 控制器│ |--user 用户相关接口| |--user.go| |--passage 文章相关接口| |--passage.go|--router 路由文件| |--router.go |—go.mod mod管理器|—go.sum 自动生成记录包的版本|—main.go main包，入口文件 引入中间件和其他工具函数新建middleware/cors.go 123456789101112131415161718192021222324252627package middlewareimport ( &quot;net/http&quot; &quot;github.com/gin-gonic/gin&quot;)//Cors 跨域中间件func Cors() gin.HandlerFunc &#123; return func(c *gin.Context) &#123; method := c.Request.Method c.Header(&quot;Access-Control-Allow-Origin&quot;, &quot;*&quot;) c.Header(&quot;Access-Control-Allow-Headers&quot;, &quot;Origin, Authorization, Content-Type,remote_user,X-Requested-With,*&quot;) c.Header(&quot;Access-Control-Allow-Headers&quot;, &quot;Content-Type, remote_user&quot;) c.Header(&quot;Access-Control-Allow-Methods&quot;, &quot;POST,OPTIONS, GET,PUT&quot;) c.Header(&quot;Access-Control-Expose-Headers&quot;, &quot;Accept , Content-Length, Access-Control-Allow-Origin, Access-Control-Allow-Headers, Content-Type&quot;) c.Header(&quot;Access-Control-Allow-Credentials&quot;, &quot;True&quot;) c.Header(&quot;Content-Type&quot;, &quot;application/json; charset=utf-8&quot;) if method == &quot;OPTIONS&quot; &#123; c.AbortWithStatus(204) c.AbortWithStatus(http.StatusNoContent) &#125; submitUser := c.Request.Header.Get(&quot;remote_user&quot;) c.Set(&quot;submitUser&quot;, submitUser) c.Next() &#125; 在cat router.go Router() 中新增 router.Use(middleware.Cors()) 123456789101112131415161718192021//Router 路由func Router() *gin.Engine &#123; router := gin.New() // 使用中间件 // 使用Logger中间件 router.Use(gin.Logger()) // 使用Recovery中间件 router.Use(gin.Recovery()) router.Use(middleware.Cors()) // 将会对所有的路由生效 userRouter := router.Group(&quot;/user&quot;) userRouter.GET(&quot;list&quot;, user.GetUserList) userRouter.GET(&quot;detail/:id&quot;, user.GetDetail) passageRouter := router.Group(&quot;/passage&quot;) passageRouter.GET(&quot;list&quot;, passage.GetPassageList) passageRouter.POST(&quot;add&quot;, passage.AddPassage) return router&#125; 当前目录结构 1234567891011121314├─controller 控制器│ |--user 用户相关接口| |--user.go| |--passage 文章相关接口| |--passage.go|--router 路由文件| |--router.go |--middleware 中间件| |--cors.go |--common 公用的函数| |--utils.go|—go.mod mod管理器|—go.sum 自动生成记录包的版本|—main.go main包，入口文件","tags":[{"name":"golang mysql gorm swagger docker shell","slug":"golang-mysql-gorm-swagger-docker-shell","permalink":"http://yoursite.com/tags/golang-mysql-gorm-swagger-docker-shell/"}]},{"title":"nginx日志","date":"2020-04-25T02:33:58.000Z","path":"2020/04/25/nginx日志/","text":"access_logaccess_log,nginx可以记录访问日志，通过日志可以查看用户访问的哪些页面比较平凡，哪些服务比较高频的调用，下面是nginx日志的语法 Syntax: access_log path [format [buffer=size] [gzip[=level]] [flush=time] [if=condition]];``access_log off; Default: access_log logs/access.log combined; Context: http, server, location, if in location, limit_except nginx.conf,access_log具体用法： 123456789101112131415http &#123; include mime.types; default_type application/octet-stream; log_format main &apos;$host $remote_addr - $remote_user [$time_local] &quot;$request&quot; &apos; &apos;$status $body_bytes_sent &quot;$http_referer&quot; &apos; &apos;&quot;$http_user_agent&quot; &quot;$http_x_forwarded_for&quot; &quot;$request_uri&quot;&apos;; access_log logs/access.log main; sendfile on; server &#123; listen 80; server_name localhost; location / &#123; index index.html; &#125;&#125; log_formatlog_format 指令指定nginx日志的输出格式， 比如上面nginx.conf 文件，log_format指令声明了main格式的(默认格式combined)，后面定义了具体的格式，当我们请求nginx，会输出如下的日志 1113.31.124.153 115.172.233.107 - - [25/Apr/2020:08:27:59 +0800] &quot;GET / HTTP/1.1&quot; 304 0 &quot;-&quot; Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/81.04044.122 Safari/537.36&quot; &quot;-&quot; &quot;/index.html&quot; 对应下面的变量, 没有用 -表示 123&apos;$host $remote_addr - $remote_user [$time_local] &quot;$request&quot; &apos;&apos;$status $body_bytes_sent &quot;$http_referer&quot; &apos;&apos;&quot;$http_user_agent&quot; &quot;$http_x_forwarded_for&quot; &quot;$request_uri&quot;&apos;; 对应变量的含义 $host 访问的域名 $remote_addr 访问的客户端ip $remote_user 用户名 $time_local 请求时间和时区 $request 请求的http信息 $status 返回状态码 $body_bytes_send 服务端返回给客户端的body信息 $http-referer 请求访问来源，根据该参数设置反盗链 $http_user_agent 客户端的访问信息 $http_x_forwarded_for 记录请求过程中的ip，再经过反向代理时，可以追踪访问的ip $request_uri 记录请求的路由 日志缓存和压缩1access_log main buffer=256k gzip flush=5; access_log 后面可以增加参数 buffer 代表在服务器内存中开启一块内存，大小这里设置为256k, nginx会先缓存日志到内存中，日志大小等256k，会写入磁盘，用来减少服务器的写入操作，提高服务器的性能，但日志将不饿能实时的看到。 gzip 代表输入的日志压缩等级，1-9代表压缩等级越来越高，写入速度越来越慢。默认值为1 flush 代表定时刷新内存中缓存的日志，写到磁盘中（不管buffer缓存的日志是否达到内存设置的上限），单位是秒。 error_log语法：error_log path level; 作用域： main http server location 示例：error_log /logs/error_log.log error; 错误日志在不同作用域中的默认级别是不同的，main: error; http: crit; server: crit; error_log 的错误级别有： debug|info|notice|warn|error|crit|alert|emerg, 从左到右级别越高，记录的错误越严重。 该指令在一个模块中同时只能出现一次，多次报错，在不同模块中，子模块会覆盖父模块的指令 1error_log /var/log/nginx/error_log crit; 日志分割split_log.sh 脚本 12345678910#/bin/bashbase_path='/usr/local/nginx/logs'echo $base_pathday=$(date +%Y%m%d)echo $daymv $base_path/access.log $base_path/access_log_$day.logPID='/usr/local/nginx/logs/nginx.pid'kill -USR1 `cat $&#123;PID&#125;` 给执行权限 chmod +x split_log.sh 加入定时脚本，一天切割一次 crontab -e 100 03 * * * /usr/local/nginx/logs/split_log.sh","tags":[{"name":"nginx","slug":"nginx","permalink":"http://yoursite.com/tags/nginx/"}]},{"title":"nginx命令行","date":"2020-04-22T14:54:15.000Z","path":"2020/04/22/nginx命令行/","text":"nginx 主要通过发射信号来控制进程，了解这些命令可以帮助我们更好的使用nginx 下面是nginx的命令思维导图 一、nginx命令行nginx 使用信号控制进程，通过nginx命令我们可以实现各种操作 nginx -s stop 直接停止nginx nginx -s quit 优雅停止nginx(nginx会在所有请求执行完毕，依次关闭进程，最后退出) nginx -s reload 重新载入配置，平滑重启nginx, 新的请求会走新的配置，老的请求处理完毕后关闭nginx进程。 nginx -s reopen 重新打开日志文件 适用于切割nginx日志操作 nginx -t 检查配置文件语法是否正确，-T 同时打印出配置文件，后面跟文件路径，可以检查某个文件 nginx -h 显示nginx的可以执行的命令 nginx -v 查看nginx版本 -V 通知显示nginx的安装信息和安装的模块。 nginx -c &lt;配置文件目录&gt; 来启动非默认的配置 nginx -p &lt;目录&gt; 来指定nginx的安装目录 nginx -g 来临时指定一些全局配置项 nginx -g “pid /var/nginx/test.pid;” 意味着把pid写到另一个文件中，-g指定的不能与默认冲突，另外以-g启动的ngix在停止事也需要加上-g nginx -g “pid /var/nginx/test.pid;” -s stop. 如果不加-g 就找不到pid文件了 二、其他命令使用1、使用系统命令来启动nginx 12345systemctl start nginx 或 service nginx start systemctl status nginx 或 service nginx statussystemctl stop nginx 或 service nginx stop 2、使用kill 启动nginx 1kill -HUP pid pid是进程标识，使用该命令发起一个挂起信号，服务器进程会进行复位操作，重新加载配置文件。 TERM, INT 快递关闭 QUIT 从容关闭 HUP 平滑重启，重新加载配置文件 USER1 重新打开日志文件 USER2 平滑升级可执行程序 WINCH 从容关闭工作进程 三、二者区别1、systemctl 或 service 启动nginx, 会关掉nginx并重新启动nginx进程id 2、nginx -s reload 或 kill -HUP pid 必须在nginx 启动后使用 3、nginx -s reload 和 kill -HUP pid 会保留旧的请求，直到连接全部结束后退出，新的请求通过新的配置启动进程。","tags":[{"name":"nginx","slug":"nginx","permalink":"http://yoursite.com/tags/nginx/"}]},{"title":"通过docker使用nginx","date":"2020-04-21T04:30:08.000Z","path":"2020/04/21/通过docker使用nginx/","text":"工作中，我们常常使用docker部署服务，这样的话，如果将nginx打包成镜像，改动起来不太方便，日志查询也很麻烦，所以我们可以将nginx和日志挂载在容器外。 服务器选择ucloud，购买请点击 一、基础相关技术：docker、nginx docker仓库：https://hub.docker.com/_/nginx 拉取不同版本的镜像：https://hub.docker.com/_/nginx?tab=tags 二、拉取镜像并启动启动一个nginx容器 注意：使用端口一定要保证端口的防火墙打开 1docker run --name some-nginx -d -p 8002:80 nginx 我们可以看到一行命令就可以启动nginx 接着我们执行命令docker exec -it some-nginx bash 就可以进入容器操作nginx的配置，从而使用它。 三、挂载nginx配置和日志上面使用docker修改配置和查看日志不方便，所以我们部署一个docker，将nginx的配置和日志放在宿主机上 1、在宿主机 /data/web 新建目录 web├── logs│ ├── access.log│ └── error.log├── nginx│ └── nginx.conf└── testWeb └── index.html nginx.conf 123456789server &#123; listen 80; server_name localhost; root /usr/share/nginx/html; location / &#123; index index.html; &#125;&#125; index.html 1this is testWeb index.html; 2、启动docker容器 1docker run --name test-nginx -d -p 8003:80 -v /data/web/logs:/var/log/nginx -v /data/web/nginx:/etc/nginx/conf.d -v /data/web/testWeb:/usr/share/nginx/html nginx 访问：curl http://localhost:8003，返回index.html内容 3、修改index.html文件 1this is testWeb index.html; this file is change; 访问：curl http://localhost:8003 返回修改后的内容，查看access.log 发现日志正常打印。","tags":[{"name":"nginx","slug":"nginx","permalink":"http://yoursite.com/tags/nginx/"},{"name":"docker","slug":"docker","permalink":"http://yoursite.com/tags/docker/"}]},{"title":"nginx源码编译","date":"2020-04-20T16:14:06.000Z","path":"2020/04/21/nginx源码编译/","text":"nginx源码编译，通常会出现很多小问题，所以对nginx要求不高，配置比较简单，可以选择工具安装. 这里由centos为例用源码进行安装 服务器选择ucloud，购买请点击 nginx是由一个个模块组成的，有一些自带的模块和大量的第三方模块，也可以自行开发第三方模块。 一、前置工作安装一些nginx依赖的库 1234567891011121314yum install -y gcc //安装GCC...安装过程省略yum install -y gcc-c++ //安装C++库用来编译c++...安装过程省略yum install -y pcre pcre-devel //安装pcre库...安装过程省略yum install -y zlib zlib-devel //安装lib库...安装过程省略yum install -y openssl openssl-devel...安装过程省略 二、下载源码12345首先创建/var/nginx目录，可以自定义cd /var/nginx 源码download #http://nginx.org/download wget http://nginx.org/download/nginx-1.9.10.tar.gz nginx源码目录 auto：一些自动编译的脚本，配合configure使用 CHANGES：版本变化 CHANGES.ru：俄罗斯语言的版本变化 conf：nginx配置文件 configure：nginx安装编译文件 contrib 存放其他机构或组织贡献的代码 html：nginx配置root默认模块 LICENSE：许可文件 man：通过man ./nginx.8查看，nginx的帮助手册 README：说明文档地址 src：nginx主要的源码分布 nginx安装指令当前目录/var/nginx/nginx-1.9.10 1./configure --help 查看安装的一些参数 –prefix=PATH 设置nginx的安装路径 –sbin-path=PATH 设置环境变量的路径 –with-http_ssl_module 等是可以安装的模块 –without-http_charset_module 等是nginx自带的模块，加上该参数可以卸载 –add-module=PATH 添加第三方模块 三、安装步骤当前目录/var/nginx/nginx-1.9.10 1234567891011121314# 执行命令，配置不同的参数，具体参数见上面安装指令./configure --prefix=/usr/local/nginx # 编译make &amp;&amp; make install# 安装完成后(nginx在/usr/local/nginx中)whereis nginx# nginx可执行文件在/usr/local/nginx/sbin/nginx 将nginx添加环境变量(软连接方式)ln -s /usr/local/nginx/sbin/nginx /usr/bin/nginx# 启动nginx 四、常见问题(1) 安装报错12345678910111213141516checking for struct tm.tm_gmtoff ... foundchecking for struct dirent.d_namlen ... not foundchecking for struct dirent.d_type ... foundchecking for sysconf(_SC_NPROCESSORS_ONLN) ... foundchecking for openat(), fstatat() ... foundchecking for getaddrinfo() ... foundchecking for PCRE library ... not foundchecking for PCRE library in /usr/local/ ... not foundchecking for PCRE library in /usr/include/pcre/ ... not foundchecking for PCRE library in /usr/pkg/ ... not foundchecking for PCRE library in /opt/local/ ... not found./configure: error: the HTTP rewrite module requires the PCRE library.You can either disable the module by using --without-http_rewrite_moduleoption, or install the PCRE library into the system, or build the PCRE librarystatically from the source with nginx by using --with-pcre=&lt;path&gt; option. 解决办法 yum install pcre-devel 1./libtool: line 990: g++: command not found 解决办法 yum -y install gcc+ gcc-c++ (2) nginx启动报错 Starting nginx (via systemctl): Job for nginx.service failed because a configured resource limit was exceeded. See “systemctl status nginx.service” and “journalctl -xe” for details. Failed to start SYSV: Nginx is an HTTP(S) server, HTTP(S) reverse proxy and IMAP/POP3 proxy server. 解决办法： netstat -ntlp 查看在运行的nginx进程 kill -9 pid 杀死正在运行的nginx进程","tags":[{"name":"nginx","slug":"nginx","permalink":"http://yoursite.com/tags/nginx/"}]},{"title":"nginx安装","date":"2020-04-19T10:06:10.000Z","path":"2020/04/19/nginx安装/","text":"nginx 是一款高并发的轻量级web代理服务器，它可以运行在Linux,Windows,Mac OS等操作系统上。 一、安装在linux（1）CentOS 安装(yum)12yum install nginx -y // 安装nginxyum remove nginx // 卸载nginx 设置nginx开机自启动 12systemctl enable nginx.servicesystemctl restart nginx.service 设置开启防火墙 12firewall-cmd --zone=public --add-port=80/tcp --permanentfirewall-cmd --reload 注：centOS 一般默认都是安装了yum，运行yum –version 查看nginx,如果没有安装，需要去安装一下 （2）utuntu 安装（apt-get）12sudo apt-get updatesudo apt-get install nginx 二、安装在window（1）下载安装包 http://nginx.org/download/（zip安装包为window安装包） （2）解压，找到exe文件 12345conf nginx 配置文件html nginx默认访问的html文件logs 日志文件（错误日志，访问日志） （3）cmd nginx当前所在的目录 相关命令 123456789101112cd C:\\Users\\user\\Downloads\\nginx-1.16.1# 查看版本nginx.exe -v# 启动start nginx 或 nginx.exe# 打开浏览器，输入http://localhost# 停止nginx.exe -s stop 或 nginx.exe -s quit# 重启nginx.exe -s reload# 重新打开日志文件nginx.exe -s reopen 注：nginx在win性能较差，所以win仅仅用来体验学习就好。","tags":[{"name":"nginx","slug":"nginx","permalink":"http://yoursite.com/tags/nginx/"}]},{"title":"hexo搭建个人博客","date":"2020-04-19T04:11:34.000Z","path":"2020/04/19/hexo搭建个人博客/","text":"从零开始搭建hexo,这是入门篇，主要介绍下hexo的初始化项目，之后慢慢记录hexo的进阶。 一、初始化项目安装node node -v 安装hexo npm install hexo -g 初始化项目 12hexo inithexo serve //运行 其他指令 123456// 生成新的文章hexo new &quot;new passage&quot;// 生成html文件hexo generate// 部署远程服务器hexo deploy 二、部署github123npm install hexo-deployer-git -Shexo cleanhexo deploy _config.yml配置 12345## Docs: https://hexo.io/docs/deployment.htmldeploy: type: git repo: &lt;你的仓库地址&gt; # https://github.com/TJ-XiaJiaHao/TJ-XiaJiaHao.github.io branch: master 访问站点github pages 设置 https://richlpf.github.io/lpf.github.io/index.html注意：1、后面要加上index.html,访问首页2、可以拉取代码，配置访问二级目录 三、安装问题静态资源无法加载问题 https://blog.csdn.net/weixin_44474742/article/details/97271608 hexo deploy 上传超时 问题 git config –global credential.helper store 四、插件系列package.json 1234567891011121314151617&quot;dependencies&quot;: &#123; &quot;hexo&quot;: &quot;^3.9.0&quot;, &quot;hexo-deployer-git&quot;: &quot;^2.1.0&quot;, &quot;hexo-generator-archive&quot;: &quot;^0.1.5&quot;, &quot;hexo-generator-category&quot;: &quot;^0.1.3&quot;, &quot;hexo-generator-feed&quot;: &quot;^2.2.0&quot;, &quot;hexo-generator-index&quot;: &quot;^0.2.1&quot;, &quot;hexo-generator-json-content&quot;: &quot;2.2.0&quot;, &quot;hexo-generator-search&quot;: &quot;^2.4.0&quot;, &quot;hexo-generator-tag&quot;: &quot;^0.2.0&quot;, &quot;hexo-renderer-ejs&quot;: &quot;^0.3.1&quot;, &quot;hexo-renderer-jade&quot;: &quot;^0.3.0&quot;, &quot;hexo-renderer-marked&quot;: &quot;^2.0.0&quot;, &quot;hexo-renderer-stylus&quot;: &quot;^0.3.3&quot;, &quot;hexo-server&quot;: &quot;^0.3.3&quot;, &quot;hexo-wordcount&quot;: &quot;^6.0.1&quot;&#125; 插入音乐或视频 https://mp.weixin.qq.com/s?__biz=MzU3MDI4NTM5Mg==&amp;mid=2247485106&amp;idx=3&amp;sn=50a8681007d7b82a29c92e70110fff1d&amp;chksm=fcf08a8dcb87039b272837b9db33f54db6bed8f3401f7d65f6caf9cec28edb1119fdfee82d41&amp;scene=21#wechat_redirect 搜索功能 自定义404页面 https://mp.weixin.qq.com/s?__biz=MzU3MDI4NTM5Mg==&amp;mid=2247485262&amp;idx=3&amp;sn=3e2aff5d7fb4979ca70d275bae48525f&amp;chksm=fcf08b71cb870267c972b11b1e5f0c345af39170c756de170adde8e70532360a68debcb0b3c4&amp;scene=21#wechat_redirect 百度seo yarn add hexo-baidu-url-push https://www.jianshu.com/p/f37452d4978e 文章字数，阅读时长统计 hexo-wordcount 评论功能 leancloud-storage –save 评论提醒 gitalk 评论系统 https://blog.csdn.net/qq_36537546/article/details/90730412","tags":[{"name":"hexo","slug":"hexo","permalink":"http://yoursite.com/tags/hexo/"}]},{"title":"mongo备份数据","date":"2019-10-23T14:05:44.000Z","path":"2019/10/23/mongo备份数据/","text":"mongo数据库的备份是必须要做的，这里记录下自己备份数据的脚本 mongo备份脚本cat /data/backdb/back_up.sh 123456789101112131415## declare an array variabledeclare -a db_arr=( &quot;testA&quot; &quot;testB&quot;)db_bk=/data/backdb/## now loop through the above arrayfor i in &quot;$&#123;db_arr[@]&#125;&quot;do echo &quot;start to dump &quot; $i mongodump -h 192.168.0.1:20000 -d $i -o $db_bk echo &quot;end&quot; # or do whatever with individual element of the arraydone 设置定时任务12345chmod +x ./backup.shcrontab -lcrontab -e40 22 * * * /data/lpf/test/backup.sh //每天22点40执行脚本","tags":[{"name":"mongo","slug":"mongo","permalink":"http://yoursite.com/tags/mongo/"}]},{"title":"mysql备份数据","date":"2019-10-23T14:04:40.000Z","path":"2019/10/23/mysql备份数据/","text":"mysql数据库的备份是必须要做的，这里记录下自己备份数据的脚本 mysql数据库备份cat /data/db/backup.sh 123456789101112#!/bin/shdb_arr=( &quot;web&quot; &quot;test&quot;)for i in &quot;$&#123;db_arr[@]&#125;&quot;do echo &quot;start to dump&quot; $i docker exec -it docker-mysql[docker_container_id/docker_name] mysqldump -h 120.132.26.176 -uroot -p[password] --databases web &gt; /data/backdb/`date &quot;+%Y%m%d&quot;`web.sql echo &quot;end to dump $&#123;db_arr[$i]&#125;&quot;done 定时脚本12345chmod +x /data/db/backup.shcrontab -lcrontab -e40 22 * * * /data/db/backup.sh //每天22点40执行脚本","tags":[{"name":"mysql","slug":"mysql","permalink":"http://yoursite.com/tags/mysql/"}]}]